// Adjust when credits text graphics are rendered to the screen.
// Because of the way a one-line vertical adjustment is forced in,
// the very first line of the credits must be drawn and erased manually.
//# address-hook(0x05b204) end(0x05b282)
function void fn05b204()
{
	if (getScreenHeightExtend() <= 0)
	{
		base.fn05b204()
		return
	}

	u16 oldCamPos = (camera.position.y >> 16) - 1
	camera.position.y += outro.scroll_speed
	u16 newCamPos = (camera.position.y >> 16) - 1

	if (camera.position.y.u16 == 0x0012)
	{
		A1 = CreditsDataGenerator.build(u16[0xfffffaae] / 4)
		u16 lineIndex = 0
		A1 = tableLookupAddress(A1, lineIndex)
		// D2.u16 encodes:
		//  - Upper byte: Credits line number when to print the text (empty lines until this is reached)
		//  - Bits 1..7:  X-position in patterns where to start the text and color
		//  - Bit 0:      Text color: white or yellow
		D2.u16 = 0x0007	// 0x0f06
		A1 += 2

		// Next actual text line
		D6.u16 = (D2.u16 & 0x0001) ? (sprite_attribute.PRIORITY | sprite_attribute.PALETTE.LINE1 | (ContinueScreen.TextTiles.targetInVRAM >> 5)) : (sprite_attribute.PRIORITY | (ContinueScreen.TextTiles.targetInVRAM >> 5))	// Includes base sprite VRAM address + the palette to use
		D2.u16 &= 0x0ffe	// This is the start offset from the left side inside plane A

		// Print next characters, read from address A1 (using ASCII encoding)
		fn05b318()
		// u16[0xfffffa84] += 2
	}

	else if (camera.position.y.u16 == 0x0112)
	{
		D1.u16 = 0x0000
		fn05b2d6()		// Clear VRAM from the very first text line that we forced into place above
	}

	else if ((oldCamPos & 0x0010) != (newCamPos & 0x0010))
	{
		// Next line of text
		D0.u16 = (newCamPos << 4) + 0x0e00
		D1.u16 = D0.u16 & 0x0f00
		fn05b2d6()		// Clear VRAM first for the text line

	#if STANDALONE
		A1 = CreditsDataGenerator.build(u16[0xfffffaae] / 4)
	#else
		u32 address = 0x05b284
		address += u16[0xfffffaae]		// Credits table index (times 4), this is either 0 or 4
		address += (global.lock_on_state == 0) ? 0 : 8	// S3&K credits has some more entries, especially in the music sections
		A1 = u32[address]
	#endif

		// u16[0xfffffa84] is the line index (times 2) of the next text to print
		u16 lineIndex = u16[0xfffffa84]
		A1 = tableLookupAddress(A1, lineIndex)

		// D2.u16 encodes:
		//  - Upper byte: Credits line number when to print the text (empty lines until this is reached)
		//  - Bits 1..7:  X-position in patterns where to start the text and color
		//  - Bit 0:      Text color: white or yellow
		D2.u16 = u16[A1]
		A1 += 2

		if (D2.u16 == 0xfff8)
		{
			// Switch to next credits table
			//  -> There are two of them, as each is limited to 0x100 lines
			//  -> It's even three for S3AIR
			fn05b294()
		}
		else if (D2.u16 == 0xfff4)
		{
			fn05b29e()
		}
		else
		{
			// D0.u16 counts up here until reaching D3.u16, producing empty lines in between
			D0.u16 &= 0xff00
			D3.u16 = (D2.u16 & 0xff00) // - (getScreenHeightExtend() << 4)
			if (D3.u16 == D0.u16)
			{
				// Next actual text line
				D6.u16 = (D2.u16 & 0x0001) ? (sprite_attribute.PRIORITY | sprite_attribute.PALETTE.LINE1 | (ContinueScreen.TextTiles.targetInVRAM >> 5)) : (sprite_attribute.PRIORITY | (ContinueScreen.TextTiles.targetInVRAM >> 5))	// Includes base sprite VRAM address + the palette to use
				D2.u16 &= 0x0ffe	// This is the start offset from the left side inside plane A

				// Adjust D2.u16 to match our one-line offset.
				D2.u16 += (getScreenHeightExtend() << 4)
				if (D2.u16 >= 0x1000)
					D2.u16 -= 0x1000

				// Print next characters, read from address A1 (using ASCII encoding)
				fn05b318()
				u16[0xfffffa84] += 2
			}
		}
	}
}

//# address-hook(0x05b2d6) end(0x05b316)
function void fn05b2d6()
{
	if (getScreenHeightExtend() == 0)
	{
		base.fn05b2d6()
		return
	}

#if !STANDALONE
	set_status_register(0x2700)
#endif

	// Update credits in plane A: Empty the text line
	u16 vramAddress = 0xc000 + D1.u16 + (getScreenHeightExtend() << 4)
	if (vramAddress >= 0xd000)
		vramAddress -= 0x1000
	for (u8 i = 0; i < 2; ++i)
	{
		VDP.setupVRAMWrite(vramAddress)
		VDP.zeroVRAM(0x50)
		vramAddress += 0x80
	}

#if !STANDALONE
	set_status_register(0x2300)
#endif
}

// Correct some garbage graphics that appear in the credits in best ending for Sonic/Tails
//# address-hook(0x05b1a2) end(0x05b1e6)
function void fn05b1a2()
{
	u16[0xfffffa86] += 0x02
	u8[0xfffffacc] = 0
#if STANDALONE
	camera.position.x.u16 = -getScreenExtend()		// Center the credits
#endif
	camera.position.y = 0
	scrolloffset.y.both = 0
	u16[0xfffffaae] = 0

	if (global.characters == CHARS_KNUCKLES_ALONE)
	{
		// Create the object that fades out music and starts the credits medley afterwards
		if (allocDynamicObjectStd())
		{
			objA1.update_address = 0x085b30
			u8[A1 + 0x2c] = 0xdc
		}
	}

	fn05b514()

	u16[0xfffffc02] = 0x0eee
	u16[0xfffffc22] = 0x00ee

	addPatternLoadingCue(0x05b1ec)

	// Remove unnecessary graphics that may occupy the scrolling plane of credits
	if (global.zone_act == 0x0d01)
	{
		VDP.setupVRAMWrite(0x1260)
		VDP.zeroVRAM(0x2c80 - 0x1260)
	}
}
