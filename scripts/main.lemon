global u16 screen_width
global s8 set_screen_size

include camera
include credits
include debug_mode
include level_layouts
include renderhooks
include resolution
include special_stage
include vram_relocations
include objects/?
include zones/?

////////////////////////////
// Display new resolution //
////////////////////////////

function void ApplyROMManipulations()
{
	base.ApplyROMManipulations()

	ROMManipulation.ScreenHeight()
	ROMManipulation.relocateGameTimeOverVRAMLoc()
}

// We set the screen resolution after the screen has fully faded to black from the previous screen
// but before any object positions, such as those of title card elements, are set.
// Note that special stages handle their own screen size setting in SpecialStage() once the screen is white.
function void initializeMainGame()
{
	set_screen_size = 1
	base.initializeMainGame()
	set_screen_size = 0
}

//# address-hook(0x003e32) end(0x004342)
function void TitleScreen()
{
	set_screen_size = -1
	base.TitleScreen()
	set_screen_size = 0
}

//# address-hook(0x003be4) end(0x003c02)
function void FadeOutScreenBlocking()
{
	base.FadeOutScreenBlocking()
	if (set_screen_size == 1 && s16(global.rolling_demo) >= 0 && useRSDKheight() && !competition_mode.active)
		Renderer.setScreenSize(screen_width, 240)
	else if (set_screen_size == -1)
		Renderer.setScreenSize(400, 224)
}

//# address-hook(0x003d30) end(0x003d4e)
function void FadeScreenToWhiteBlocking()
{
	base.FadeScreenToWhiteBlocking()
	if (set_screen_size == 1 && s16(global.rolling_demo) >= 0 && useRSDKheight() && !competition_mode.active)
		Renderer.setScreenSize(screen_width, 240)
}

// Fix the Knuckles demo. With the extra screen size, the dragonfly spawns slightly earlier which causes
// Knuckles to crash into it, so adjust the dragonfly's flight slightly.
global u32 demo_mhz_dragonfly

//# address-hook(0x08dd32) end(0x08dd32)
function void Dragonfly.Init()
{
	if (objA0.position.x == 0x10400000 && objA0.position.y == 0x09480000 && global.demo_number == 4)
		demo_mhz_dragonfly = A0

	base.Dragonfly.Init()
}

//# address-hook(0x08ddaa) end(0x08dde4)
function void fn08ddaa()
{
	base.fn08ddaa()
	if (objA0.velocity.y == 0 && A0 == demo_mhz_dragonfly)
	{
		demo_mhz_dragonfly = 0
		objA0.countdown_value += 8
	}
}

////////////////////////////////
// Move dynamic objects table //
////////////////////////////////

// Formerly 0xffffe380 .. 0xffffe3ff, now 0x8ae380 .. 0x8ae3ff
// Table of dynamic objects in range
//  - First word ("size") is twice the number of objects in the table
//  - After that, each entry is word per object, telling us the RAM address of a dynamic object (lower u16 part only)
define global.dynamic_objects.size_new	= u16[0x8ae380]
constant u32 global.dynamic_objects.array_newstartloc = 0x8ae380

//# address-hook(0x01040c) end(0x01041c)
function void AddAsDynamicObject()
{
	if (global.dynamic_objects.size_new < 0x7e)
	{
		global.dynamic_objects.size_new += 2
		u16[global.dynamic_objects.array_newstartloc + global.dynamic_objects.size_new] = A0.u16
	}
}

//# address-hook(0x006c2c) end(0x006c32)
function void ResetDynamicObjectList()
{
	global.dynamic_objects.size_new = 0
}

//# address-hook(0x00ff06) end(0x00ff5e)
function void Character.CheckCollisionsWithDynamicObjects_partial()
{
#if STANDALONE
	// Bounding box of player
	if (DEBUG_DYNAMIC_COLLISIONS)
		debugDrawRect(D2.u16, D3.u16, D4.u16, D5.u16, 0x8000ff00)
#endif

	u16 numObjects = global.dynamic_objects.size_new		// Actually it's twice the number of dynamic objects
	A4 = addressof(global.dynamic_objects.size_new) + 2		// Resulting address: 0x8ae382
	while (numObjects != 0)
	{
		// Get address of dynamic object
		A1 = 0xffff0000 + u16[A4]
		A4 += 2

		// Offset into a list of hitbox sizes (the list looks a bit random)
		u16 offset = objA1.collision_attributes
		if (offset != 0)
		{
			// Targets:
			//  - 0x04 x 0x04  -> (offset & collision_attributes.size) = collision.size.4x4
			//  - 0x14 x 0x14  -> (offset & collision_attributes.size) = collision.size.20x20
			//  - 0x0c x 0x14  -> (offset & collision_attributes.size) = collision.size.12x20
			//  - 0x14 x 0x0c  -> (offset & collision_attributes.size) = collision.size.20x12
			//  - 0x04 x 0x10  -> (offset & collision_attributes.size) = collision.size.4x16
			//  - 0x0c x 0x12  -> (offset & collision_attributes.size) = collision.size.12x18
			//  - 0x10 x 0x10  -> (offset & collision_attributes.size) = collision.size.16x16
			//  - 0x06 x 0x06  -> (offset & collision_attributes.size) = collision.size.6x6
			//  - 0x18 x 0x0c  -> (offset & collision_attributes.size) = collision.size.24x12
			//  - 0x0c x 0x10  -> (offset & collision_attributes.size) = collision.size.12x16
			//  - 0x10 x 0x08  -> (offset & collision_attributes.size) = collision.size.16x8
			//  - 0x08 x 0x08  -> (offset & collision_attributes.size) = collision.size.8x8
			//  - 0x14 x 0x10  -> (offset & collision_attributes.size) = collision.size.20x16
			//  - 0x14 x 0x08  -> (offset & collision_attributes.size) = collision.size.20x8
			//  - 0x0e x 0x0e  -> (offset & collision_attributes.size) = collision.size.14x14
			//  - 0x18 x 0x18  -> (offset & collision_attributes.size) = collision.size.24x24
			//  - 0x28 x 0x10  -> (offset & collision_attributes.size) = collision.size.40x16
			//  - 0x10 x 0x18  -> (offset & collision_attributes.size) = collision.size.16x24
			//  - 0x08 x 0x10  -> (offset & collision_attributes.size) = collision.size.8x16
			//  - 0x20 x 0x70  -> (offset & collision_attributes.size) = collision.size.32x112
			//  - 0x40 x 0x20  -> (offset & collision_attributes.size) = collision.size.64x32
			//  - 0x80 x 0x20  -> (offset & collision_attributes.size) = collision.size.128x32
			//  - 0x20 x 0x20  -> (offset & collision_attributes.size) = collision.size.32x32
			//  - 0x08 x 0x08  -> (offset & collision_attributes.size) = collision.size.8x8_2
			//  - 0x04 x 0x04  -> (offset & collision_attributes.size) = collision.size.4x4_2
			//  - 0x20 x 0x08  -> (offset & collision_attributes.size) = collision.size.32x8
			//  - 0x0c x 0x0c  -> (offset & collision_attributes.size) = collision.size.12x12
			//  - 0x08 x 0x04  -> (offset & collision_attributes.size) = collision.size.8x4
			//  - 0x18 x 0x04  -> (offset & collision_attributes.size) = collision.size.24x4
			//  - 0x28 x 0x04  -> (offset & collision_attributes.size) = collision.size.40x4
			//  - 0x04 x 0x08  -> (offset & collision_attributes.size) = collision.size.4x8
			//  - 0x04 x 0x18  -> (offset & collision_attributes.size) = collision.size.4x24
			//  - 0x04 x 0x28  -> (offset & collision_attributes.size) = collision.size.4x40
			//  - 0x18 x 0x18  -> (offset & collision_attributes.size) = collision.size.24x24_2
			//  - 0x18 x 0x18  -> (offset & collision_attributes.size) = collision.size.24x24_3
			//  - 0x0c x 0x18  -> (offset & collision_attributes.size) = collision.size.12x24
			//  - 0x48 x 0x08  -> (offset & collision_attributes.size) = collision.size.72x8
			//  - 0x18 x 0x28  -> (offset & collision_attributes.size) = collision.size.24x40
			//  - 0x10 x 0x04  -> (offset & collision_attributes.size) = collision.size.16x4
			//  - 0x20 x 0x02  -> (offset & collision_attributes.size) = collision.size.32x2
			//  - 0x10 x 0x1c  -> (offset & collision_attributes.size) = collision.size.16x28
			//  - 0x0c x 0x24  -> (offset & collision_attributes.size) = collision.size.12x36
			//  - 0x10 x 0x02  -> (offset & collision_attributes.size) = collision.size.16x2
			//  - 0x04 x 0x40  -> (offset & collision_attributes.size) = collision.size.4x64
			//  - 0x18 x 0x40  -> (offset & collision_attributes.size) = collision.size.24x64
			//  - 0x20 x 0x10  -> (offset & collision_attributes.size) = collision.size.32x16
			//  - 0x1c x 0x14  -> (offset & collision_attributes.size) = collision.size.28x20
			//  - 0x10 x 0x02  -> (offset & collision_attributes.size) = collision.size.16x2_2
			//  - 0x10 x 0x01  -> (offset & collision_attributes.size) = collision.size.16x1
			//  - 0x02 x 0x08  -> (offset & collision_attributes.size) = collision.size.2x8
			//  - 0x10 x 0x40  -> (offset & collision_attributes.size) = collision.size.16x64
			//  - 0x0c x 0x04  -> (offset & collision_attributes.size) = collision.size.12x4
			//  - 0x08 x 0x0c  -> (offset & collision_attributes.size) = collision.size.8x12
			//  - 0x28 x 0x20  -> (offset & collision_attributes.size) = collision.size.40x32
			//  - 0x40 x 0x02  -> (offset & collision_attributes.size) = collision.size.64x2
			//  - 0x60 x 0x02  -> (offset & collision_attributes.size) = collision.size.96x2
			//  - 0x28 x 0x28  -> (offset & collision_attributes.size) = collision.size.40x40
			A2 = 0x00ff62 + (offset & collision_attributes.size) * 2
			s16 hitbox.x = u8[A2]
			s16 hitbox.y = u8[A2+1]

			u16 px = objA1.position.x.u16 - hitbox.x
			u16 py = objA1.position.y.u16 - hitbox.y
			u16 sx = hitbox.x * 2
			u16 sy = hitbox.y * 2

		#if STANDALONE
			if (DEBUG_DYNAMIC_COLLISIONS)
			{
				if ((offset & collision_attributes.flags) == collision.flag.ITEM)
					debugDrawRect(px, py, sx, sy, 0x8000ff00)
				else if ((offset & collision_attributes.flags) == collision.flag.SPECIAL)
					debugDrawRect(px, py, sx, sy, 0x80ff0000)
				else if ((offset & collision_attributes.flags) == collision.flag.THREAT)
					debugDrawRect(px, py, sx, sy, 0x800000ff)
				else
					debugDrawRect(px, py, sx, sy, 0x80ff00ff)
			}
		#endif

			if (checkBoxOverlap(D2.u16, D3.u16, D4.u16, D5.u16, px, py, sx, sy))
			{
				// Collision found
				Character.OnCollisionWithDynamicObject()
				return
			}
		}

		numObjects -= 2
	}
}

//# address-hook(0x01041e) end(0x0104e8)
function void UpdateShieldDeflecting()
{
	// Any shield active?
	if ((char.bonus_effect & char.bonus.ALL_SHIELDS) == 0)
		return

	// Bounding box of shield, or projectile deflection range
	D2.u16 = char.position.x.u16 - 0x18
	D3.u16 = char.position.y.u16 - 0x18
	D4.u16 = 0x30
	D5.u16 = 0x30

#if STANDALONE
	if (DEBUG_DYNAMIC_COLLISIONS >= 2)
		debugDrawRect(D2.u16, D3.u16, D4.u16, D5.u16, 0x8000ffff)
#endif

	u16 numObjects = global.dynamic_objects.size_new		// Actually it's twice the number of dynamic objects
	A4 = addressof(global.dynamic_objects.size_new) + 2		// Resulting address: 0x8ae382
	while (numObjects != 0)
	{
		// Get address of dynamic object
		A1 = 0xffff0000 + u16[A4]
		A4 += 2

		// Check for deflectable object
		u8 collisionFlags = (objA1.collision_attributes & collision_attributes.flags)
		if (collisionFlags == collision.flag.THREAT)
		{
			// Offset into a list of hitbox sizes?
			u16 offset = (objA1.collision_attributes & collision_attributes.size)
			if (offset != 0)
			{
				// Targets:
				//  - 0x04 x 0x04  -> offset = collision.size.4x4
				//  - 0x14 x 0x14  -> offset = collision.size.20x20
				//  - 0x0c x 0x14  -> offset = collision.size.12x20
				//  - 0x14 x 0x0c  -> offset = collision.size.20x12
				//  - 0x04 x 0x10  -> offset = collision.size.4x16
				//  - 0x0c x 0x12  -> offset = collision.size.12x18
				//  - 0x10 x 0x10  -> offset = collision.size.16x16
				//  - 0x06 x 0x06  -> offset = collision.size.6x6
				//  - 0x18 x 0x0c  -> offset = collision.size.24x12
				//  - 0x0c x 0x10  -> offset = collision.size.12x16
				//  - 0x10 x 0x08  -> offset = collision.size.16x8
				//  - 0x08 x 0x08  -> offset = collision.size.8x8
				//  - 0x14 x 0x10  -> offset = collision.size.20x16
				//  - 0x14 x 0x08  -> offset = collision.size.20x8
				//  - 0x0e x 0x0e  -> offset = collision.size.14x14
				//  - 0x18 x 0x18  -> offset = collision.size.24x24
				//  - 0x28 x 0x10  -> offset = collision.size.40x16
				//  - 0x10 x 0x18  -> offset = collision.size.16x24
				//  - 0x08 x 0x10  -> offset = collision.size.8x16
				//  - 0x20 x 0x70  -> offset = collision.size.32x112
				//  - 0x40 x 0x20  -> offset = collision.size.64x32
				//  - 0x80 x 0x20  -> offset = collision.size.128x32
				//  - 0x20 x 0x20  -> offset = collision.size.32x32
				//  - 0x08 x 0x08  -> offset = collision.size.8x8_2
				//  - 0x04 x 0x04  -> offset = collision.size.4x4_2
				//  - 0x20 x 0x08  -> offset = collision.size.32x8
				//  - 0x0c x 0x0c  -> offset = collision.size.12x12
				//  - 0x08 x 0x04  -> offset = collision.size.8x4
				//  - 0x18 x 0x04  -> offset = collision.size.24x4
				//  - 0x28 x 0x04  -> offset = collision.size.40x4
				//  - 0x04 x 0x08  -> offset = collision.size.4x8
				//  - 0x04 x 0x18  -> offset = collision.size.4x24
				//  - 0x04 x 0x28  -> offset = collision.size.4x40
				//  - 0x18 x 0x18  -> offset = collision.size.24x24_2
				//  - 0x18 x 0x18  -> offset = collision.size.24x24_3
				//  - 0x0c x 0x18  -> offset = collision.size.12x24
				//  - 0x48 x 0x08  -> offset = collision.size.72x8
				//  - 0x18 x 0x28  -> offset = collision.size.24x40
				//  - 0x10 x 0x04  -> offset = collision.size.16x4
				//  - 0x20 x 0x02  -> offset = collision.size.32x2
				//  - 0x10 x 0x1c  -> offset = collision.size.16x28
				//  - 0x0c x 0x24  -> offset = collision.size.12x36
				//  - 0x10 x 0x02  -> offset = collision.size.16x2
				//  - 0x04 x 0x40  -> offset = collision.size.4x64
				//  - 0x18 x 0x40  -> offset = collision.size.24x64
				//  - 0x20 x 0x10  -> offset = collision.size.32x16
				//  - 0x1c x 0x14  -> offset = collision.size.28x20
				//  - 0x10 x 0x02  -> offset = collision.size.16x2_2
				//  - 0x10 x 0x01  -> offset = collision.size.16x1
				//  - 0x02 x 0x08  -> offset = collision.size.2x8
				//  - 0x10 x 0x40  -> offset = collision.size.16x64
				//  - 0x0c x 0x04  -> offset = collision.size.12x4
				//  - 0x08 x 0x0c  -> offset = collision.size.8x12
				//  - 0x28 x 0x20  -> offset = collision.size.40x32
				//  - 0x40 x 0x02  -> offset = collision.size.64x2
				//  - 0x60 x 0x02  -> offset = collision.size.96x2
				//  - 0x28 x 0x28  -> offset = collision.size.40x40
				A2 = 0x00ff62 + offset * 2
				s16 hitbox.x = u8[A2]
				s16 hitbox.y = u8[A2+1]

				u16 px = objA1.position.x.u16 - hitbox.x
				u16 py = objA1.position.y.u16 - hitbox.y
				u16 sx = hitbox.x * 2
				u16 sy = hitbox.y * 2

			#if STANDALONE
				if (DEBUG_DYNAMIC_COLLISIONS >= 2)
					debugDrawRect(px, py, sx, sy, 0x8000ffff)
			#endif

				if (checkBoxOverlap(D2.u16, D3.u16, D4.u16, D5.u16, px, py, sx, sy))
				{
					if (u8[A1 + 0x2b] & char.bonus.DEFLECTABLE)
					{
						deflectProjectile()
						return
					}
				}
			}
		}

		numObjects -= 2
	}
}

function void Character.clearEnemiesOnScreen(u16 minY)
{
	push(A4)
	push(A3)
	push(A2)

	// Go through all the badniks to destroy
	D6.u16 = global.dynamic_objects.size_new
	A4 = addressof(global.dynamic_objects.size_new) + 2		// Resulting address: 0x8ae382
	while (D6.u16 != 0)
	{
		// Get address of dynamic object
		A1 = 0xffff0000 + u16[A4]
		A4 += 2

		D0 = objA1.collision_attributes
		if (D0.u8 != 0)
		{
		#if STANDALONE
			// Assuming minY is only set for lightning shield touching water
			if (minY > 0)
			{
				if (objA1.position.y.u16 >= minY)
				{
					fn01050c()
				}
			}
			else
		#endif
			{
				fn01050c()
			}
		}
		D6.u16 -= 2
	}

	A2 = pop()
	A3 = pop()
	A4 = pop()
}

//# address-hook(0x02d638) end(0x02d68a)
function void fn02d638()
{
	global.dynamic_objects.size_new = 0
	if ((objA0.animation.sprite & 0x01) == 0)
	{
		D0.u8 = (control.pad1.pressed | control.pad2.pressed) & (CONTROL_START | CONTROL_ABC)
		if (D0.u8 == 0 && u16[A0 + 0x24] != 0)
		{
			--u16[A0 + 0x24]
		}
		else
		{
			if (global.time_over)
			{
				checkpoint.time = 0
				level.restart = 1

			#if STANDALONE
				Standalone.onDeath()
			#endif
			}
			else
			{
				global.game_mode = (continues_counter == 0) ? 0 : 0x14		// Initialization/Continue Screen
			}
		}
	}
	DrawObject()
}

//# address-hook(0x01a3fe) end(0x01a432)
function void fn01a3fe()
{
	D1 = 0

	// Go through all the badniks to destroy
	D6.u16 = global.dynamic_objects.size_new
	A4 = addressof(global.dynamic_objects.size_new) + 2		// Resulting address: 0x8ae382
	if (D6.u16 != 0)
	{
		u8[0xfffff66c] += 2
		if (u8[0xfffff66c] >= D6.u8)
		{
			u8[0xfffff66c] = 0
		}

		D0 = u8[0xfffff66c]
		D6.u16 -= D0.u16
		A4 += D0.s16
		while (D6.u16 != 0)
		{
			// Get address of dynamic object
			A1 = 0xffff0000 + u16[A4]
			A4 += 2

			D0.u8 = objA1.collision_attributes
			if (D0.u8 != 0)
			{
				fn01a434()
			}
			D6.u16 -= 2
		}
	}
}

////////////////
// Draw level //
////////////////

//# address-hook(0x04ed90) end(0x04edb0)
function void LoadTileContentDefault()
{
	A6 = addressof(camera.foreground.x)			// Address: 0xffffee80
	A5 = addressof(camera.foreground.x.old)		// Address: 0xffffee88
	D1.u16 = camera.foreground.y.u16
	D6 = getScreenHeight()/16 + 1	// formerly 0x0f, which is for getScreenHeight() = 224
	LoadTileContentInDirX()

	A6 = addressof(camera.foreground.y)			// Address: 0xffffee84
	A5 = addressof(camera.foreground.y.old)		// Address: 0xffffee8a
	D1.u16 = camera.foreground.x.u16
	D6 = (getScreenWidth() + 31) / 16
	LoadTileContentInDirY()
}

//# address-hook(0x04edb4) end(0x04edd4)
function void UpdateBackgroundTiles.General()
{
	A6 = addressof(camera.background.x)			// Address: 0xffffee8c
	A5 = addressof(camera.background.x.old)		// Address: 0xffffee94
	D1.u16 = camera.background.y.u16
	D6 = getScreenHeight()/16 + 1	// formerly 0x0f, which is for getScreenHeight() = 224
	LoadTileContentInDirX()

	A6 = addressof(camera.background.y)			// Address: 0xffffee90
	A5 = addressof(camera.background.y.old)		// Address: 0xffffee96
	D1.u16 = camera.background.x.u16
	D6 = (getScreenWidth() + 31) / 16
	LoadTileContentInDirY()
}

//# address-hook(0x04ead8) end(0x04eb20)
function void LoadTileContentInDirY()
{
	u16 oldOffset = u16[A5]
	u16 newOffset = u16[A6] & level.height.tilemask
	u16[A5] = newOffset

	// Anything to do?
	s16 diff = oldOffset - newOffset
	if (diff == 0)
		return

	// Note that there are cases where s8(diff) is actually zero here, though diff is not (e.g. LBZ1 cutscene before boss)
	if (s8(diff) >= 0)
	{
		// Screen moved up
		D0.u16 = newOffset
	}
	else
	{
		// Screen moved down
		diff = -diff
		D0.u16 = (oldOffset + getScreenHeight() + 16) & level.height.tilemask		// formerly 0xf0 = 240 = screen height + 16
	}
	u8[0xffffeea4] = ((diff & 0x30) != 0x10) ? 0xff : 0x00

	//debugLog(stringformat("LoadTileContentInDirY (%d lines): posX=0x%04x, posY=0x%04x, rows=0x%02x", u8[0xffffeea4] ? 2 : 1, D0, D1, D6.u16))

	u32 backupD1 = D1
	u32 backupD6 = D6
	LoadTileContentSingleLine()
	D1 = backupD1
	D6 = backupD6

	if (u8[0xffffeea4] != 0)
	{
		D0.u16 = (D0.u16 + 0x10) & level.height.tilemask
		LoadTileContentSingleLine()
	}
}

//# address-hook(0x04eb22) end(0x04eb68)
function void fn04eb22()
{
	// Updates background sprite patterns in some zones (e.g. AIZ 1 and MHZ)
	u16 oldOffset = u16[A5]
	u16 newOffset = u16[A6] & level.height.tilemask
	u16[A5] = newOffset

	// Anything to do?
	s16 diff = oldOffset - newOffset
	if (diff == 0)
		return

	// Note that there are cases where s8(diff) is actually zero here, though diff is not
	if (s8(diff) >= 0)
	{
		// Screen moved up
		D0.u16 = newOffset
	}
	else
	{
		// Screen moved down
		diff = -diff
		D0.u16 = (oldOffset + getScreenHeight() + 16) & level.height.tilemask		// formerly 0xf0 = 240 = screen height + 16
		D1 = (D1 << 16) + (D1 >> 16)
	}
	u8[0xffffeea4] = ((diff & 0x30) != 0x10) ? 0xff : 0x00

	u16 backupD1 = D1.u16
	u16 backupD6 = D6.u16
	LoadTileContentSingleLine()
	D1.u16 = backupD1
	D6.u16 = backupD6

	if (u8[0xffffeea4] != 0)
	{
		D0.u16 = (D0.u16 + 0x10) & level.height.tilemask
		LoadTileContentSingleLine()
	}
}

//# address-hook(0x04ee20) end(0x04ee82)
function void fn04ee20()
{
	D1.u16 = D6.u16
	while (true)
	{
		D6.u16 -= u16[A4]
		A4 += 2
		if (D6.s16 < 0)
			break

		D0.u16 = u16[A6] & 0xfff0
		u16[A6 + 2] = D0.u16
		A6 += 4
		--D5.u16
	}

	D6.s16 = -D6.s16
	D6.u16 >>= 4
	D4 = getScreenHeight()/16 + 1	// formerly 0x0f, which is for getScreenHeight() = 224
	D4.u16 -= D6.u16
	if (D4.s16 < 0)
	{
		D4 = 0
		D6 = getScreenHeight()/16 + 1	// formerly 0x0f, which is for getScreenHeight() = 224
	}

	while (true)
	{
		u16 backupD1 = D1.u16
		u16 backupD4 = D4.u16
		u16 backupD5 = D5.u16
		u16 backupD6 = D6.u16
		u32 backupA4 = A4
		u32 backupA6 = A6

		A5 = A6 + 2
		LoadTileContentInDirX()

		A4 = backupA4
		A6 = backupA6
		D1.u16 = backupD1
		D4.u16 = backupD4
		D5.u16 = backupD5
		D6.u16 = backupD6

		A6 += 4
		if (D4.u16 == 0)
			break

		D6.u16 <<= 4
		D1.u16 += D6.u16
		--D5.u16
		D6.u16 = u16[(A4+=2)-2] >> 4
		D0.u16 = D4.u16
		D4.u16 -= D6.u16
		if (D4.s16 < 0)
		{
			D6.u16 = D0.u16
			D4 = 0
		}
	}

	while (true)
	{
		--D5.u16
		if (D5.u16 == 0)
			break

		D0.u16 = u16[(A6+=2)-2] & 0xfff0
		u16[(A6+=2)-2] = D0.u16
	}
}

////////////////
// Draw Rings //
////////////////

//# address-hook(0x00e8be) end(0x00e940)
function void InitStaticRings()
{
	rings.update_routine += 2
	fn00eb1a()

	if (global.zone == 0x14)	// Glowing Spheres bonus stage
	{
		rings.update_routine += 2

		A1 = rings.around.first
		A2 = 0xffff8600
		D4.u16 = camera.position.y.u16 - 8
		if (D4.s16 <= 0)
			D1 = 1

		while (D4.u16 > u16[A1 + 2])
		{
			A1 += 4
			A2 += 2
		}
		rings.around.first = A1
		rings.around.first.state = A2.u16
		D4.u16 += getScreenHeight() + 16		// formerly 0xf0 = 240 = screen height + 16

		while (D4.u16 > u16[A1 + 2])
		{
			A1 += 4
		}
		rings.around.last = A1
	}
	else
	{
		A1 = rings.around.first
		A2 = 0xffffe700
		D4.u16 = camera.position.x.u16 - 8
		if (D4.s16 <= 0)
			D4 = 1

		while (D4.u16 > u16[A1])
		{
			A1 += 4
			A2 += 2
		}
		rings.around.first = A1
		rings.around.first.state = A2.u16
		D4.u16 += 0x150

		while (D4.u16 > u16[A1])
		{
			A1 += 4
		}
		rings.around.last = A1
	}
}

//# address-hook(0x00eb86) end(0x00ebec)
function void RenderStaticRings()
{
	A0 = rings.around.first
	u32 numRings = (rings.around.last - rings.around.first) / 4
	if (numRings != 0)
	{
		A4 = 0xffff0000 + rings.around.first.state
		A1 = 0x00ebee
		D5.u16 = getScreenHeight() + 16		// formerly 0xf0 = 240 = screen height + 16
		u16 camera_x = u16[A3]		// Usually camera.foreground.x
		u16 camera_y = u16[A3+4]	// Usually camera.foreground.y

		while (numRings > 0)
		{
			u16 ringAnimationState = u16[A4]
			if (ringAnimationState != 0xffff)
			{
				D1.u16 = (u16[A0+2] - camera_y + 8) & level.height.bitmask
				if (D1.u16 < D5.u16)
				{
					D1.u16 += 0x78
					D0.u16 = u16[A0] - camera_x + 0x80

					u8 animFrame = ringAnimationState & 0xff
					if (animFrame == 0)
					{
						// For non-collected rings, use rotating animation
						animFrame = static_rings.animframe
					}
					u32 src = A1 + animFrame * 8

					u16 px = u16[src + 6] + D0.u16
					u16 py = u16[src + 0] + D1.u16
					u8 size = u8[src + 3]
					u16 index = u16[src + 4]

				#if STANDALONE
					if ((ringAnimationState & 0xff) == 0)
					{
						// Custom smoother ring animations
						animFrame = ((static_rings.animframe * 8 + 7 - static_rings.animtimer) / 4) % 8
						u64 key = stringformat("ring_0%d", animFrame)
						u16 x = D0.u16 - 0x80
						u16 y = D1.u16 - 0x80
						Renderer.drawCustomSprite(key, x, y, 0x00, 0, 0xa000)
					}
					else
					{
						Renderer.drawVdpSprite(px - 0x80, py - 0x80, size, index, 0xc000)
					}
				#endif

					u16[A6 + 0] = py
					 u8[A6 + 2] = size
					u16[A6 + 4] = index
					u16[A6 + 6] = px
					A6 += 8
					--D7.u16
				}
			}
			A4 += 2
			A0 += 4
			--numRings
		}
	}
}

//////////////
// Draw HUD //
//////////////

// Render the life counter at an appropriate height.
// Also prevent debug mode from using VRAM to draw its HUD information.
//# address-hook(0x00db44) end(0x00dbb2)
function void RenderHUD()
{
#if STANDALONE
	if (DEBUG_DISABLE_HUD)
		return
#endif

	s16 baseX = global.level_started
	if (baseX < 0)
	{
		baseX += 8
		global.level_started = baseX
	}
	baseX += 0x0f
	s16 baseY = 0x08
	u16 renderQueue = 0xe000

	bool isBonusStage = (global.zone >= 0x13 && global.zone <= 0x15)
#if STANDALONE
//	if (!debug_mode.state)
//	{
		if (!isBonusStage)
		{
			// Score
			HUD.drawSprite("hud_text_score", baseX, baseY, renderQueue)
			++renderQueue
			HUD.drawNumber("hud_digit_%d", player.score * 10, baseX + 0x58, baseY, renderQueue)
			++renderQueue

			// Time
			{
				bool show = (timer.minutes < 9 || isBonusStage || (level.framecounter & 0x08) || Game.getSetting(SETTING_INFINITE_TIME))
				HUD.drawSprite(show ? "hud_text_time" : "hud_text_time_red", baseX, baseY + 0x10, renderQueue)
				++renderQueue

				// Unfortunately, the time progress is done later inside the frame, so we don't have the right value in "timer.frames" yet
				//  -> If the conditions for time progress are met, add one and everything will be alright
				u16 minutes = timer.minutes
				u16 seconds = timer.seconds
				u16 frames = timer.frames
				if (hud.dirty.timer && !global.game.paused && timer.alldata < 0x93b3b)	// That is 9:59 and 59 frames
				{
					++frames
					seconds += (frames / 60)
					minutes += (seconds / 60)
					frames %= 60
					seconds %= 60
				}
				u16 centiseconds = (frames * 99 + 30) / 59

				u16 px = (minutes >= 10) ? (baseX + 8) : baseX
				if (Game.getSetting(SETTING_EXTENDED_HUD))
				{
					if (minutes >= 10)
						HUD.drawDigit(minutes / 10, px + 0x20, baseY + 0x10, renderQueue)
					HUD.drawDigit(minutes % 10, px + 0x28, baseY + 0x10, renderQueue)
					HUD.drawSprite("hud_char_minutes", px + 0x30, baseY + 0x10, renderQueue)
					HUD.drawDigit(seconds / 10, px + 0x38, baseY + 0x10, renderQueue)
					HUD.drawDigit(seconds % 10, px + 0x40, baseY + 0x10, renderQueue)
					HUD.drawSprite("hud_char_seconds", px + 0x48, baseY + 0x10, renderQueue)
					HUD.drawDigit(centiseconds / 10, px + 0x50, baseY + 0x10, renderQueue)
					if (minutes < 10)
						HUD.drawDigit(centiseconds % 10, px + 0x58, baseY + 0x10, renderQueue)
				}
				else
				{
					if (minutes >= 10)
						HUD.drawDigit(minutes / 10, px + 0x20, baseY + 0x10, renderQueue)
					HUD.drawDigit(minutes % 10, px + 0x28, baseY + 0x10, renderQueue)
					HUD.drawSprite("hud_char_colon", px + 0x30, baseY + 0x10, renderQueue)
					HUD.drawDigit(seconds / 10, px + 0x38, baseY + 0x10, renderQueue)
					HUD.drawDigit(seconds % 10, px + 0x40, baseY + 0x10, renderQueue)
				}
				++renderQueue
			}
		}

		// Rings
		{
			u16 py = (isBonusStage) ? baseY : baseY + 0x20
			bool show = (ring_counter != 0 || (level.framecounter & 0x08))
			HUD.drawSprite(show ? "hud_text_rings" : "hud_text_rings_red", baseX, py, renderQueue)
			++renderQueue

			u16 px = baseX + (!isBonusStage && Game.getSetting(SETTING_EXTENDED_HUD) ? 0x58 : 0x40)
			for (u32 value = ring_counter;;)
			{
				HUD.drawDigit(value % 10, px, py, renderQueue)
				px -= 8
				value /= 10
				if (value == 0)
					break
			}
			++renderQueue
		}

		// Lives (not visible in Time Attack or with infinite lives setting)
		if (!Game.isTimeAttack() && !Game.getSetting(SETTING_INFINITE_LIVES))
		{
			bool useMobilePosition = HUD.useMobileLivesDisplay()
			u16 px = useMobilePosition ? (getScreenWidth() - baseX - 0x30) : baseX
			u16 py = useMobilePosition ? baseY : getScreenHeight() - 24 // formerly 200

			HUD.drawSprite(getCharacterLivesIcon(getMainCharacter()), px, py, renderQueue)
			++renderQueue

			if (lives_counter >= 10)
				HUD.drawSmallDigit(u16((lives_counter / 10) % 10), px + 0x20, py + 8, renderQueue)
			HUD.drawSmallDigit(u16(lives_counter % 10), px + 0x28, py + 8, renderQueue)
		}
//	}
//	else
#endif
/*
	{
		D4 = (isBonusStage) ? 8 : 0

		if ((level.framecounter & 0x08) == 0)
		{
			if (ring_counter == 0)
			{
				D4 += 2		// Set rings HUD text to flicker
			}
			if (timer.minutes == 9 && !isBonusStage)
			{
				D4 += 4		// Set timer HUD text to flicker
			}
		}

		// Targets:
		//  - 0x00dbc2	-> D4.u16 = 0x00		// Complete HUD text
		//  - 0x00dc00	-> D4.u16 = 0x02		// HUD with rings text flickering
		//  - 0x00dc32	-> D4.u16 = 0x04		// HUD with time text flickering
		//  - 0x00dc6a	-> D4.u16 = 0x06		// HUD with both rings and time flickering
		//  - 0x00dc96	-> D4.u16 = 0x08		// Bonus stage HUD
		//  - 0x00dcb6	-> D4.u16 = 0x0a		// Bonus stage HUD with rings text flickering
		A1 = tableLookupAddress(0x00dbb6, D4.u16)

		D4.s16 = u16[A1] - 1
		D0.s16 = baseX + 0x80
		D1.u16 = 0x0108
		D5.u16 = 0x86ca
		A1 += 2
		if (D4.s16 >= 0)
		{
			writeToSpriteTable(renderQueue)
		}
	}
*/
}

// Do not update HUD elements in VRAM. We are using that VRAM for shields,
// super sparks, and GAME/TIME OVER while AIR draws the HUD as images.
function void refreshHudDisplayShared(u8 numDigits, bool showAllDigits)
{
	return
/*	
	u32 decimal = pow(10, numDigits - 1)

	while (decimal > 0)
	{
		u8 digit = D1 / decimal
		D1 %= decimal

		if (digit != 0)
		{
			// From now on, show all digits (don't skip leading zeroes any more)
			showAllDigits = true
		}

		if (showAllDigits)
		{
			// Location of sprite for this digit
			A3 = 0x00e18a + digit * 0x40

			u32 vramAddress = VDPHelper.getVRAMAddressFromWriteCode(D0)
			VDP.setupVRAMWrite(vramAddress)
			VDP.copyToVRAM(A3, 0x40)
		}

		D0 += 0x400000
		decimal /= 10
	}
*/
}

//# address-hook(0x00e11e) end(0x00e188)
function void UpdateHudLivesDisplay()
{
	return
/*
	u16 vramAddress = 0xfba0
	u16 number = lives_counter
	u8 digit = 10

	while (digit > 0)
	{
		u8 counter = 0
		while (number >= digit)
		{
			number -= digit
			++counter
		}

		VDP.setupVRAMWrite(vramAddress)
		if (counter > 0 || digit == 1)
		{
			A3 = 0x00e48a + counter * 0x20
			VDP.copyToVRAM(A3, 0x20)
		}
		else
		{
			VDP.zeroVRAM(0x20)
		}

		vramAddress += 0x40
		digit /= 10
	}
*/
}

//# address-hook(0x00defc) end(0x00df52)
function void DebugModePositionDisplay()
{
	return
/*
	// Initialize direct VRAM write
	VDP.setupVRAMWrite(0xdc40)

	D1 = (u32(camera.position.x.u16) << 16) + u16[0xffffb000 + 0x10]
	fn00df1c()

	D1 = (u32(camera.position.y.u16) << 16) + u16[0xffffb000 + 0x14]
	fn00df1c()
*/
}

//# address-hook(0x00de88) end(0x00de9a)
function void ResetRingsDisplay()
{
	return
/*
	// Initialize direct VRAM write
	VDP.setupVRAMWrite(0xdf40)
	A2 = 0x00def8
	D2.u16 = 2
	fn00debe()
*/
}

//# address-hook(0x00de9c) end(0x00deba)
function void ResetScoreDisplay()
{
	return
/*
	UpdateHudLivesDisplay()
	if (competition_mode.active)
		return

	// Initialize direct VRAM write
	VDP.setupVRAMWrite(0xdc40)
	A2 = 0x00deec
	D2.u16 = 14
	fn00debe()
*/
}
