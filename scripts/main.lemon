global u16 screen_width
global s8 set_screen_size

include camera
include credits
include debug_mode
include level_layouts
include renderhooks
include resolution
include special_stage
include vram_relocations
include objects/?
include zones/?

////////////////////////////
// Display new resolution //
////////////////////////////

function void ApplyROMManipulations()
{
	base.ApplyROMManipulations()

	ROMManipulation.ScreenHeight()
	ROMManipulation.relocateGameTimeOverVRAMLoc()
}

// We set the screen resolution after the screen has fully faded to black from the previous screen
// but before any object positions, such as those of title card elements, are set.
// Note that special stages handle their own screen size setting in SpecialStage() once the screen is white.
function void initializeMainGame()
{
	set_screen_size = 1
	base.initializeMainGame()
	set_screen_size = 0
}

//# address-hook(0x003e32) end(0x004342)
function void TitleScreen()
{
	set_screen_size = -1
	base.TitleScreen()
	set_screen_size = 0
}

//# address-hook(0x003be4) end(0x003c02)
function void FadeOutScreenBlocking()
{
	base.FadeOutScreenBlocking()
	if (set_screen_size == 1 && s16(global.rolling_demo) >= 0 && useRSDKheight() && !competition_mode.active)
		Renderer.setScreenSize(screen_width, 240)
	else if (set_screen_size == -1)
		Renderer.setScreenSize(400, 224)
}

//# address-hook(0x003d30) end(0x003d4e)
function void FadeScreenToWhiteBlocking()
{
	base.FadeScreenToWhiteBlocking()
	if (set_screen_size == 1 && s16(global.rolling_demo) >= 0 && useRSDKheight() && !competition_mode.active)
		Renderer.setScreenSize(screen_width, 240)
}

// Fix the Knuckles demo. With the extra screen size, the dragonfly spawns slightly earlier which causes
// Knuckles to crash into it, so adjust the dragonfly's flight slightly.
global u32 demo_mhz_dragonfly

//# address-hook(0x08dd32) end(0x08dd32)
function void Dragonfly.Init()
{
	if (objA0.position.x == 0x10400000 && objA0.position.y == 0x09480000 && global.demo_number == 4)
		demo_mhz_dragonfly = A0

	base.Dragonfly.Init()
}

//# address-hook(0x08ddaa) end(0x08dde4)
function void fn08ddaa()
{
	base.fn08ddaa()
	if (objA0.velocity.y == 0 && A0 == demo_mhz_dragonfly)
	{
		demo_mhz_dragonfly = 0
		objA0.countdown_value += 8
	}
}

// With the increased screen height, the scroll offset table overflows into the dynamic object table.
// However, the dynamic object table is only used during UpdateGameObjects(), and the scroll offset
// table is never used at that time. So we can store the dynamic object table in a different address,
// swap it into place during UpdateGameObjects(), and then swap it back out after.

function void SwapMemory(u32 adr1, u32 adr2, u32 bytes)
{
	for (u32 i = 0; i < bytes; i += 4)
	{
		u32 temp = u32[adr1 + i]
		u32[adr1 + i] = u32[adr2 + i]
		u32[adr2 + i] = temp
	}
}

function void UpdateGameObjects()
{
	SwapMemory(0xffffe380, 0x8ae380, 0x80)
	base.UpdateGameObjects()
	SwapMemory(0xffffe380, 0x8ae380, 0x80)
}

////////////////
// Draw level //
////////////////

//# address-hook(0x04ed90) end(0x04edb0)
function void LoadTileContentDefault()
{
	A6 = addressof(camera.foreground.x)			// Address: 0xffffee80
	A5 = addressof(camera.foreground.x.old)		// Address: 0xffffee88
	D1.u16 = camera.foreground.y.u16
	D6 = getScreenHeight()/16 + 1	// formerly 0x0f, which is for getScreenHeight() = 224
	LoadTileContentInDirX()

	A6 = addressof(camera.foreground.y)			// Address: 0xffffee84
	A5 = addressof(camera.foreground.y.old)		// Address: 0xffffee8a
	D1.u16 = camera.foreground.x.u16
	D6 = (getScreenWidth() + 31) / 16
	LoadTileContentInDirY()
}

//# address-hook(0x04edb4) end(0x04edd4)
function void UpdateBackgroundTiles.General()
{
	A6 = addressof(camera.background.x)			// Address: 0xffffee8c
	A5 = addressof(camera.background.x.old)		// Address: 0xffffee94
	D1.u16 = camera.background.y.u16
	D6 = getScreenHeight()/16 + 1	// formerly 0x0f, which is for getScreenHeight() = 224
	LoadTileContentInDirX()

	A6 = addressof(camera.background.y)			// Address: 0xffffee90
	A5 = addressof(camera.background.y.old)		// Address: 0xffffee96
	D1.u16 = camera.background.x.u16
	D6 = (getScreenWidth() + 31) / 16
	LoadTileContentInDirY()
}

//# address-hook(0x04ead8) end(0x04eb20)
function void LoadTileContentInDirY()
{
	u16 oldOffset = u16[A5]
	u16 newOffset = u16[A6] & level.height.tilemask
	u16[A5] = newOffset

	// Anything to do?
	s16 diff = oldOffset - newOffset
	if (diff == 0)
		return

	// Note that there are cases where s8(diff) is actually zero here, though diff is not (e.g. LBZ1 cutscene before boss)
	if (s8(diff) >= 0)
	{
		// Screen moved up
		D0.u16 = newOffset
	}
	else
	{
		// Screen moved down
		diff = -diff
		D0.u16 = (oldOffset + getScreenHeight() + 16) & level.height.tilemask		// formerly 0xf0 = 240 = screen height + 16
	}
	u8[0xffffeea4] = ((diff & 0x30) != 0x10) ? 0xff : 0x00

	//debugLog(stringformat("LoadTileContentInDirY (%d lines): posX=0x%04x, posY=0x%04x, rows=0x%02x", u8[0xffffeea4] ? 2 : 1, D0, D1, D6.u16))

	u32 backupD1 = D1
	u32 backupD6 = D6
	LoadTileContentSingleLine()
	D1 = backupD1
	D6 = backupD6

	if (u8[0xffffeea4] != 0)
	{
		D0.u16 = (D0.u16 + 0x10) & level.height.tilemask
		LoadTileContentSingleLine()
	}
}

//# address-hook(0x04eb22) end(0x04eb68)
function void fn04eb22()
{
	// Updates background sprite patterns in some zones (e.g. AIZ 1 and MHZ)
	u16 oldOffset = u16[A5]
	u16 newOffset = u16[A6] & level.height.tilemask
	u16[A5] = newOffset

	// Anything to do?
	s16 diff = oldOffset - newOffset
	if (diff == 0)
		return

	// Note that there are cases where s8(diff) is actually zero here, though diff is not
	if (s8(diff) >= 0)
	{
		// Screen moved up
		D0.u16 = newOffset
	}
	else
	{
		// Screen moved down
		diff = -diff
		D0.u16 = (oldOffset + getScreenHeight() + 16) & level.height.tilemask		// formerly 0xf0 = 240 = screen height + 16
		D1 = (D1 << 16) + (D1 >> 16)
	}
	u8[0xffffeea4] = ((diff & 0x30) != 0x10) ? 0xff : 0x00

	u16 backupD1 = D1.u16
	u16 backupD6 = D6.u16
	LoadTileContentSingleLine()
	D1.u16 = backupD1
	D6.u16 = backupD6

	if (u8[0xffffeea4] != 0)
	{
		D0.u16 = (D0.u16 + 0x10) & level.height.tilemask
		LoadTileContentSingleLine()
	}
}

//# address-hook(0x04ee20) end(0x04ee82)
function void fn04ee20()
{
	D1.u16 = D6.u16
	while (true)
	{
		D6.u16 -= u16[A4]
		A4 += 2
		if (D6.s16 < 0)
			break

		D0.u16 = u16[A6] & 0xfff0
		u16[A6 + 2] = D0.u16
		A6 += 4
		--D5.u16
	}

	D6.s16 = -D6.s16
	D6.u16 >>= 4
	D4 = getScreenHeight()/16 + 1	// formerly 0x0f, which is for getScreenHeight() = 224
	D4.u16 -= D6.u16
	if (D4.s16 < 0)
	{
		D4 = 0
		D6 = getScreenHeight()/16 + 1	// formerly 0x0f, which is for getScreenHeight() = 224
	}

	while (true)
	{
		u16 backupD1 = D1.u16
		u16 backupD4 = D4.u16
		u16 backupD5 = D5.u16
		u16 backupD6 = D6.u16
		u32 backupA4 = A4
		u32 backupA6 = A6

		A5 = A6 + 2
		LoadTileContentInDirX()

		A4 = backupA4
		A6 = backupA6
		D1.u16 = backupD1
		D4.u16 = backupD4
		D5.u16 = backupD5
		D6.u16 = backupD6

		A6 += 4
		if (D4.u16 == 0)
			break

		D6.u16 <<= 4
		D1.u16 += D6.u16
		--D5.u16
		D6.u16 = u16[(A4+=2)-2] >> 4
		D0.u16 = D4.u16
		D4.u16 -= D6.u16
		if (D4.s16 < 0)
		{
			D6.u16 = D0.u16
			D4 = 0
		}
	}

	while (true)
	{
		--D5.u16
		if (D5.u16 == 0)
			break

		D0.u16 = u16[(A6+=2)-2] & 0xfff0
		u16[(A6+=2)-2] = D0.u16
	}
}

////////////////
// Draw Rings //
////////////////

//# address-hook(0x00e8be) end(0x00e940)
function void InitStaticRings()
{
	rings.update_routine += 2
	fn00eb1a()

	if (global.zone == 0x14)	// Glowing Spheres bonus stage
	{
		rings.update_routine += 2

		A1 = rings.around.first
		A2 = 0xffff8600
		D4.u16 = camera.position.y.u16 - 8
		if (D4.s16 <= 0)
			D1 = 1

		while (D4.u16 > u16[A1 + 2])
		{
			A1 += 4
			A2 += 2
		}
		rings.around.first = A1
		rings.around.first.state = A2.u16
		D4.u16 += getScreenHeight() + 16		// formerly 0xf0 = 240 = screen height + 16

		while (D4.u16 > u16[A1 + 2])
		{
			A1 += 4
		}
		rings.around.last = A1
	}
	else
	{
		A1 = rings.around.first
		A2 = 0xffffe700
		D4.u16 = camera.position.x.u16 - 8
		if (D4.s16 <= 0)
			D4 = 1

		while (D4.u16 > u16[A1])
		{
			A1 += 4
			A2 += 2
		}
		rings.around.first = A1
		rings.around.first.state = A2.u16
		D4.u16 += 0x150

		while (D4.u16 > u16[A1])
		{
			A1 += 4
		}
		rings.around.last = A1
	}
}

//# address-hook(0x00eb86) end(0x00ebec)
function void RenderStaticRings()
{
	A0 = rings.around.first
	u32 numRings = (rings.around.last - rings.around.first) / 4
	if (numRings != 0)
	{
		A4 = 0xffff0000 + rings.around.first.state
		A1 = 0x00ebee
		D5.u16 = getScreenHeight() + 16		// formerly 0xf0 = 240 = screen height + 16
		u16 camera_x = u16[A3]		// Usually camera.foreground.x
		u16 camera_y = u16[A3+4]	// Usually camera.foreground.y

		while (numRings > 0)
		{
			u16 ringAnimationState = u16[A4]
			if (ringAnimationState != 0xffff)
			{
				D1.u16 = (u16[A0+2] - camera_y + 8) & level.height.bitmask
				if (D1.u16 < D5.u16)
				{
					D1.u16 += 0x78
					D0.u16 = u16[A0] - camera_x + 0x80

					u8 animFrame = ringAnimationState & 0xff
					if (animFrame == 0)
					{
						// For non-collected rings, use rotating animation
						animFrame = static_rings.animframe
					}
					u32 src = A1 + animFrame * 8

					u16 px = u16[src + 6] + D0.u16
					u16 py = u16[src + 0] + D1.u16
					u8 size = u8[src + 3]
					u16 index = u16[src + 4]

				#if STANDALONE
					if ((ringAnimationState & 0xff) == 0)
					{
						// Custom smoother ring animations
						animFrame = ((static_rings.animframe * 8 + 7 - static_rings.animtimer) / 4) % 8
						u64 key = stringformat("ring_0%d", animFrame)
						u16 x = D0.u16 - 0x80
						u16 y = D1.u16 - 0x80
						Renderer.drawCustomSprite(key, x, y, 0x00, 0, 0xa000)
					}
					else
					{
						Renderer.drawVdpSprite(px - 0x80, py - 0x80, size, index, 0xc000)
					}
				#endif

					u16[A6 + 0] = py
					 u8[A6 + 2] = size
					u16[A6 + 4] = index
					u16[A6 + 6] = px
					A6 += 8
					--D7.u16
				}
			}
			A4 += 2
			A0 += 4
			--numRings
		}
	}
}

//////////////
// Draw HUD //
//////////////

// Render the life counter at an appropriate height.
// Also prevent debug mode from using VRAM to draw its HUD information.

global bool adjust_HUD

//# address-hook(0x00db44) end(0x00dbb2)
function void RenderHUD()
{
	if (debug_mode.state)
		return
	
	adjust_HUD = true
	base.RenderHUD()
	adjust_HUD = false
}

function void HUD.drawSprite(u64 key, u16 px, u16 py, u16 renderQueue)
{
	if (adjust_HUD && !HUD.useMobileLivesDisplay())
		py += getScreenHeight() - 224
	
	base.HUD.drawSprite(key, px, py, renderQueue)
}

function void HUD.drawSmallDigit(u8 digit, u16 px, u16 py, u16 renderQueue)
{
	if (adjust_HUD && !HUD.useMobileLivesDisplay())
		py += getScreenHeight() - 224
	
	base.HUD.drawSmallDigit(digit, px, py, renderQueue)
}

// Do not update HUD elements in VRAM. We are using that VRAM for shields,
// super sparks, and GAME/TIME OVER while AIR draws the HUD as images.
function void refreshHudDisplayShared(u8 numDigits, bool showAllDigits)
{
	return
/*	
	u32 decimal = pow(10, numDigits - 1)

	while (decimal > 0)
	{
		u8 digit = D1 / decimal
		D1 %= decimal

		if (digit != 0)
		{
			// From now on, show all digits (don't skip leading zeroes any more)
			showAllDigits = true
		}

		if (showAllDigits)
		{
			// Location of sprite for this digit
			A3 = 0x00e18a + digit * 0x40

			u32 vramAddress = VDPHelper.getVRAMAddressFromWriteCode(D0)
			VDP.setupVRAMWrite(vramAddress)
			VDP.copyToVRAM(A3, 0x40)
		}

		D0 += 0x400000
		decimal /= 10
	}
*/
}

//# address-hook(0x00e11e) end(0x00e188)
function void UpdateHudLivesDisplay()
{
	return
/*
	u16 vramAddress = 0xfba0
	u16 number = lives_counter
	u8 digit = 10

	while (digit > 0)
	{
		u8 counter = 0
		while (number >= digit)
		{
			number -= digit
			++counter
		}

		VDP.setupVRAMWrite(vramAddress)
		if (counter > 0 || digit == 1)
		{
			A3 = 0x00e48a + counter * 0x20
			VDP.copyToVRAM(A3, 0x20)
		}
		else
		{
			VDP.zeroVRAM(0x20)
		}

		vramAddress += 0x40
		digit /= 10
	}
*/
}

//# address-hook(0x00defc) end(0x00df52)
function void DebugModePositionDisplay()
{
	return
/*
	// Initialize direct VRAM write
	VDP.setupVRAMWrite(0xdc40)

	D1 = (u32(camera.position.x.u16) << 16) + u16[0xffffb000 + 0x10]
	fn00df1c()

	D1 = (u32(camera.position.y.u16) << 16) + u16[0xffffb000 + 0x14]
	fn00df1c()
*/
}

//# address-hook(0x00de88) end(0x00de9a)
function void ResetRingsDisplay()
{
	return
/*
	// Initialize direct VRAM write
	VDP.setupVRAMWrite(0xdf40)
	A2 = 0x00def8
	D2.u16 = 2
	fn00debe()
*/
}

//# address-hook(0x00de9c) end(0x00deba)
function void ResetScoreDisplay()
{
	return
/*
	UpdateHudLivesDisplay()
	if (competition_mode.active)
		return

	// Initialize direct VRAM write
	VDP.setupVRAMWrite(0xdc40)
	A2 = 0x00deec
	D2.u16 = 14
	fn00debe()
*/
}
