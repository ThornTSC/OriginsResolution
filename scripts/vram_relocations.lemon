// We change the VRAM location for shields and other similar objects to be
// in place of SCORE/TIME/RINGS text, which A.I.R. renderhooks anyway.
// This prevents their graphics from being overwritten by the extra VRAM
// space used to extend the screen vertically.
constant u16 Shield.new_VRAM_target = 0xd940 // original value is 0xf380.
global bool init_sprite_attributes
global bool move_shield_sprite_patterns

function void updateMultipleSpritePatterns(u32 sourceBase, u32 tableAddress, u16 targetInVRAM, u16 animationSprite)
{
	if (sourceBase == 0x18c084 || sourceBase == 0x18c704 || sourceBase == 0x18e8a4 || sourceBase == 0x18f984)
		move_shield_sprite_patterns = true
	
	base.updateMultipleSpritePatterns(sourceBase, tableAddress, targetInVRAM, animationSprite)
	move_shield_sprite_patterns = false
}

function void updateSpritePattern(u32 sourceInROM, u16 targetInVRAM, u16 lengthInWords)
{
	if ((sourceInROM == 0x18a204 || sourceInROM == 0x18bd44 || sourceInROM == 0x18f8e4) || move_shield_sprite_patterns)
		targetInVRAM -= (0xf380 - Shield.new_VRAM_target)

	base.updateSpritePattern(sourceInROM, targetInVRAM, lengthInWords)
}

function void Kosinski.addToDMAQueue(u32 sourceAddress, u16 targetInVRAM)
{
	// Hyper Sonic stars
	if (sourceAddress == 0x14c652 && targetInVRAM == 0xf380)
		targetInVRAM = Shield.new_VRAM_target
	
	base.Kosinski.addToDMAQueue(sourceAddress, targetInVRAM)
}

function void Shield.sharedInit()
{
	base.Shield.sharedInit()
	objA0.sprite_attributes = Shield.new_VRAM_target >> 5
}

//# address-hook(0x0187f0) end(0x018862)
//# alias(fn0187f0) deprecated
function void Invincibility.Init()
{
	init_sprite_attributes = true
	base.Invincibility.Init()
	init_sprite_attributes = false
}

//# address-hook(0x018868) end(0x0188e4)
//# alias(fn018868) deprecated
function void Invincibility.Update()
{
	if (init_sprite_attributes)
	{
		A1 = A0
		for (u8 i = 0; i < 4; ++i)
		{
			objA1.sprite_attributes == Shield.new_VRAM_target >> 5
			A1 += 0x4a
		}
	}
	base.Invincibility.Update()
}

// Hyper Sonic stars in DDZ
//# address-hook(0x08242a) end(0x08244c)
function void fn08242a()
{
	base.fn08242a()
	objA0.sprite_attributes = sprite_attribute.PRIORITY | (Shield.new_VRAM_target >> 5)
}

// Hyper Sonic stars
//# address-hook(0x01937c) end(0x0193c4)
function void fn01937c()
{
	init_sprite_attributes = true
	base.fn01937c()
	init_sprite_attributes = false
}

//# address-hook(0x0193ca) end(0x0193e6)
//# alias(fn0193ca) deprecated
function void HyperSonicStars.CreateSparks()
{
	if (init_sprite_attributes)
		objA0.sprite_attributes = Shield.new_VRAM_target >> 5
	
	base.HyperSonicStars.CreateSparks()
}

//# address-hook(0x0193ec) end(0x019486)
function void fn0193ec()
{
	if (init_sprite_attributes)
		objA0.sprite_attributes = Shield.new_VRAM_target >> 5
	
	base.fn0193ec()
}

// Super Sonic stars - Init
//# address-hook(0x019156) end(0x01919e)
function void fn019156()
{
	init_sprite_attributes = true
	base.fn019156()
	init_sprite_attributes = false

	fn0191a4()
}

// Super Sonic stars - Update
//# address-hook(0x0191a4) end(0x019230)
function void fn0191a4()
{
	if (init_sprite_attributes)
		objA0.sprite_attributes = Shield.new_VRAM_target >> 5
	
	base.fn0191a4()
}

// Sparkles just before a Super Emerald activates or after getting all Super Emeralds.
// We also control the post-Super Emerald results vertical scroll here.
//# address-hook(0x02e616) end(0x02e744)
function void fn02e616()
{
	if (objA0.countdown_value != 0)
	{
		--objA0.countdown_value
		return
	}

	D0.u16 = camera.position.y.u16
	if (D0.u16 < 0x0320 - getScreenHeightExtend())
	{
		++D0.u16
		camera.position.y.u16 = D0.u16
		if (D0.u16 != 0x02a0 - getScreenHeightExtend())
			return

		D0 = 4
		if (bluespheres.rings_collected >= 50)
		{
			D1.u16 = u16[0xffffeee0]
			if (D1.u16 != 0)
			{
				A1 = 0xffff0000 + D1.u16
				objA1.update_address = 0x02ec4a
				u16[A1 + 0x2e] = 0x14
			}
			++D0.u16
		}
		u16[A0 + 0x30] = D0.u16

		A1 = 0xffffb98a
		while (D0.s16 >= 0)
		{
			objA1.update_address = 0x02ec1e
			A1 += 0x4a
			--D0.s16
		}

		D0 = (global.super_emeralds >= 7) ? 4 : 2
		u16[A0 + 0x30] += D0.u16

		A1 = 0xffffbd96
		while (D0.s16 >= 0)
		{
			objA1.update_address = 0x02ec1e
			A1 += 0x4a
			--D0.s16
		}

		u16[A0 + 0x30] += 2

		A1 = 0xffffb98a
		u16[A1 + 0x2e] = 0x08
		u16[A1 + 0x4a + 0x2e] = 0x0c
		u16[A1 + 0x94 + 0x2e] = 0x0c
		u16[A1 + 0xde + 0x2e] = 0x10
		u16[A1 + 0x0128 + 0x2e] = 0x10
		if (bluespheres.rings_collected >= 50)
		{
			u16[A1 + 0x0172 + 0x2e] = 0x14
		}
		u16[A1 + 0x94 + 0x16] = 0
		u16[A1 + 0x0128 + 0x16] = 0

		A1 = 0xffffbd96
		u16[A1 + 0x94 + 0x2e] = 0x04
		if (global.super_emeralds >= 7)
		{
			u16[A1 + 0x0128 + 0x2e] = 0x04
		}
	}
	else
	{
		updateSpritePattern(0x18a204, Shield.new_VRAM_target, 0x0200)

		if (allocDynamicObjectStd())
		{
			D1 = 0
			D2 = 0
			D3 = 7
			while (D3.s16 >= 0)
			{
				objA1.update_address = 0x02ecd0
				u16[A1 + 0x2e] = D1.u16
				u16[A1 + 0x30] = D2.u16
				u16[A1 + 0x34] = A0.u16
				D1.u16 += 0x10
				++D2.u16
				if (!allocDynamicObjectAfterA1())
					break

				--D3.s16
			}
		}

		objA0.countdown_value = 0x1e
		u16[A0 + 0x30] = 0
		objA0.base_state += 2

		playSound(0xb8)
	}
}

//# address-hook(0x02ecd0) end(0x02ed26)
function void fn02ecd0()
{
	init_sprite_attributes = true
	base.fn02ecd0()
	init_sprite_attributes = false
}

//# address-hook(0x02ed2a) end(0x02edca)
function void fn02ed2a()
{
	if (init_sprite_attributes)
		objA0.sprite_attributes = (sprite_attribute.PRIORITY | (Shield.new_VRAM_target >> 5))
	
	base.fn02ed2a()
}

// GAME/TIME OVER texts are also moved from the old location to the new one, but those
// get their own file because they also get vertically repositioned with screen height changes.
// They also have a ROM manipulation applied to alter their pattern load queue.