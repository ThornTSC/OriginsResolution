// Adjust character shadow positions for new screen size
function void BlueSpheres.renderCustomCharacterShadows()
{
	if (Game.getSetting(SETTING_BS_VISUAL_STYLE) & 0x02)
	{
		Renderer.drawCustomSprite(getNumPlayers() < 2 ? "bluespheres_shadow_1P_smooth" : "bluespheres_shadow_2P_smooth", 142 + getScreenExtend(), 149 + getScreenHeightExtend(), 0x00, 0, 0x3100)
	}
	else
	{
		Renderer.drawCustomSprite(getNumPlayers() < 2 ? "bluespheres_shadow_1P_pixel" : "bluespheres_shadow_2P_pixel", 142 + getScreenExtend(), 149 + getScreenHeightExtend(), 0x00, 0, 0x3100)
	}
}


// Adjust horizon position for new screen size
function void BlueSpheres.renderCustomGround()
{
	BlueSpheres.replacePlaneRendering()

	// Render glow effect for background
	if (Game.getSetting(SETTING_BS_VISUAL_STYLE) & 0x02)
	{
		Renderer.drawSprite("bluespheres_glow_background", getScreenWidth() / 2, 20 + getScreenHeightExtend(), 0x00, 0, 0x2000)
	}

	// Render our own version of the ground
	//  -> This only works in combination with a palette set in V-Int, see "fn000c50"
	string spriteKey1
	string spriteKey2
	{
		Game.setupBlueSpheresGroundSprites()

		u16 px = bluespheres.position.x
		u16 py = bluespheres.position.y
		u8 rotation = bluespheres.direction
		bool isRotating = (rotation & 0x3f) != 0
		if (isRotating || (rotation & 0x40) == 0)
			px = (px + 0x80) & 0xff00
		if (isRotating || (rotation & 0x40) != 0)
			py = (py + 0x80) & 0xff00

		if (isRotating)
		{
			u8 rotationStep = (rotation & 0x3f) / 4
			spriteKey1 = stringformat("bluespheres_ground_alpha_rotation_0x%02x", rotationStep)
			spriteKey2 = stringformat("bluespheres_ground_opaque_rotation_0x%02x", rotationStep)
		}
		else
		{
			u8 movementStep = 0
			if ((rotation & 0x80) == 0)
			{
				movementStep = (0xff - ((rotation & 0x40) ? px : py) & 0xff) / 8
			}
			else
			{
				movementStep = (((rotation & 0x40) ? px : py) & 0xff) / 8
			}
			spriteKey1 = stringformat("bluespheres_ground_alpha_movement_0x%02x", movementStep)
			spriteKey2 = stringformat("bluespheres_ground_opaque_movement_0x%02x", movementStep)
		}
	}
	Renderer.drawSprite(spriteKey1, 0, 0, 0x100, 0, 0x3000)
	Renderer.drawSprite(spriteKey2, 0, 0, 0x100, SPRITE_FLAG_FULLY_OPAQUE, 0x3000)		// Draw fully opaque (here meant only as a rendering optimization, primarily for software renderer)

	// Render glow effect on top
	if (Game.getSetting(SETTING_BS_VISUAL_STYLE) & 0x02)
	{
		Renderer.drawSprite("bluespheres_glow_foreground", getScreenWidth() / 2, 30 + getScreenHeightExtend(), 0x00, 0, 0x3100)
	}
}

// Adjust sphere rendering for new screen size
function void BlueSpheres.renderCustomSpheres()
{
	u32 ptr = 0x800000
	Game.writeBlueSpheresData(ptr, 0xfffff100, bluespheres.position.x, bluespheres.position.y, bluespheres.direction)

	u16 count = u16[ptr]
	ptr += 2
	for (u16 i = 0; i < count; ++i)
	{
		// Read sphere properties
		u16 px = u16[ptr] + getScreenExtend() - 40
		u16 py = u16[ptr+2]
		u16 size = u16[ptr+4]
		u8 sphereType = u8[ptr+6]
		ptr += 7

		// Size of sphere (0 = largest at 32x32, 0x0f = smallest at 8x8, the last ones include 3x 2 duplicates, which makes only 13 different sizes in total, with 2 pixels size difference between them)
		u8 form
		if (size < 0x1740)
			form = 0x0f
		else if (size < 0x18a0)
			form = 0x0e
		else if (size < 0x1a10)
			form = 0x0d
		else if (size < 0x1b90)
			form = 0x0c
		else if (size < 0x1d30)
			form = 0x0b
		else if (size < 0x1f00)
			form = 0x0a
		else if (size < 0x2100)
			form = 0x09
		else if (size < 0x2330)
			form = 0x08
		else if (size < 0x25a0)
			form = 0x07
		else if (size < 0x2960)
			form = 0x06
		else if (size < 0x2c80)
			form = 0x05
		else if (size < 0x3180)
			form = 0x04
		else if (size < 0x35c0)
			form = 0x03
		else if (size < 0x3c80)
			form = 0x02
		else if (size < 0x4500)
			form = 0x01
		else
			form = 0x00

		py -= (16 - form) * 2/3 + 1

		// Lift spheres when stage was won
		py -= bluespheres.lifted_height

		bool behindHorizon = (size < 0x1b00)
		u16 renderQueue = (behindHorizon ? 0x2000 : 0x9000) + size / 0x100
		u8 alpha = (sphereType == 0x0a) ? 0xa0 : 0xff
		u32 fog = clamp(s32(0x100000) / size - 0x68, 0, 0x80) * 0x010101

		D0.u16 = u8(sphereType) * 8
		A3 = u32[0xffffe480 + D0.u16]
		D6.u16 = u16[0xffffe480 + D0.u16 + 4]

		D0.u16 = u16[0xffffe480 + D0.u16 + 6]
		D1 = (D0.u16 & 0x8000) ? 0 : (form * 2)
		D1.u16 += D0.u16 * 2
		A3 = tableLookupAddress(A3, D1.s16)

		D1.u16 = u16[A3] - 1	// This is always 0, except for Super Emeralds
		A3 += 2
		while (D1.s16 >= 0)
		{
			if (Game.getSetting(SETTING_BS_VISUAL_STYLE) & 0x02)
			{
				Renderer.drawVdpSpriteWithTint(px + u16[A3+4], py + s8[A3] + getScreenHeightExtend(), u8[A3+1], u16[A3+2] + D6.u16, renderQueue, (0xffffff - fog) + (u32(alpha) << 24), fog)
			}
			else
			{
				Renderer.drawVdpSprite(px + u16[A3+4], py + s8[A3] + getScreenHeightExtend(), u8[A3+1], u16[A3+2] + D6.u16, renderQueue)
			}

			A3 += 6
			--D1.s16
		}
	}
}

// Shift GET BLUE SPHERES and PERFECT text to match screen height changes
//# address-hook(0x008e5c) end(0x008e8e)
function void fn008e5c()
{
	objA0.box_size.x = 0x80
	objA0.box_size.y = 0x80
	objA0.sprite_priority = 0
	objA0.mapping_offset = 0x008f5e
	objA0.sprite_attributes = (sprite_attribute.PRIORITY | sprite_attribute.PALETTE.LINE1 | (SpecialStage.TextPromps.targetInVRAM >> 5))
	objA0.position.x.u16 = 0x120 + getScreenExtend()
	objA0.position.y.u16 = 0xe8 + getScreenHeightExtend()
	objA0.value32 = 0xb4

	objA0.update_address = 0x008e94
	fn008e94()
}

// Set camera y position for Hidden Palace during Super Emerald stage results to match screen height changes

global bool adjust_cameraY

//# address-hook(0x02df64) end(0x02e2be)
function void fn02df64()
{
	adjust_cameraY = true
	base.fn02df64()
	adjust_cameraY = false
}

//# address-hook(0x01b690) end(0x01b696)
function void DynamicObjectsLoading()
{
	if (adjust_cameraY)
		camera.position.y.u16 -= getScreenHeightExtend()
	
	base.DynamicObjectsLoading()
}

//# address-hook(0x02e616) end(0x02e744)
function void fn02e616()
{
	camera.position.y.u16 += getScreenHeightExtend()
	base.fn02e616()
	camera.position.y.u16 -= getScreenHeightExtend()
}